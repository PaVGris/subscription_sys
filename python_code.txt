manage.py
============================================================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()


############################################################

apps\payments\models.py
============================================================
from django.contrib.auth.models import User
from django.db import models
from apps.subscriptions.models import Subscription, Plan


class PaymentMethodRef(models.Model):
    PROVIDER_CHOICES = [
        ('fake', 'Fake Gateway'),
        ('yoomoney', 'YooMoney'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='payment_methods')
    provider = models.CharField(
        max_length=20,
        choices=PROVIDER_CHOICES,
        default='fake'
    )
    stripe_payment_method_id = models.CharField(max_length=255, unique=True)
    is_default = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'payment_methods'

    def __str__(self):
        return f"{self.user.username} - {self.provider}"


class Invoice(models.Model):
    """–°—á–µ—Ç–∞"""

    STATUS_CHOICES = [
        ('PENDING', 'Pending'),
        ('PAID', 'Paid'),
        ('FAILED', 'Failed'),
        ('CANCELED', 'Canceled'),
    ]

    subscription = models.ForeignKey(Subscription, on_delete=models.CASCADE, related_name='invoices')
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    currency = models.CharField(max_length=3, default='RUB')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='PENDING')
    billing_period_start = models.DateField(null=True, blank=True)
    billing_period_end = models.DateField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'invoices'
        indexes = [
            models.Index(fields=['status', 'created_at']),
        ]

    def __str__(self):
        return f"Invoice {self.id} - {self.status}"


class Payment(models.Model):
    STATUS_CHOICES = [
        ('NEW', 'New'),
        ('PENDING', 'Pending'),
        ('SUCCEEDED', 'Succeeded'),
        ('FAILED', 'Failed'),
        ('CANCELED', 'Canceled'),
        ('ERROR', 'Error'),
    ]

    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE, related_name='payments')
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    provider = models.CharField(max_length=50, default='fake')
    provider_payment_id = models.CharField(max_length=255, null=True, blank=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='NEW')
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    currency = models.CharField(max_length=3, default='RUB')
    idempotency_key = models.CharField(max_length=255, unique=True, db_index=True)
    raw_request = models.TextField(null=True, blank=True)
    raw_response = models.TextField(null=True, blank=True)
    retry_count = models.IntegerField(default=0)
    next_retry_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'payments'
        indexes = [
            models.Index(fields=['status']),
            models.Index(fields=['next_retry_at', 'status']),
        ]

    def __str__(self):
        return f"Payment {self.id} - {self.status}"


class TransactionHistoryEntry(models.Model):
    TYPE_CHOICES = [
        ('CHARGE', 'Charge'),
        ('REFUND', 'Refund'),
        ('ADJUSTMENT', 'Adjustment'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='transactions')
    subscription = models.ForeignKey(
        Subscription,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='transactions'
    )
    type = models.CharField(max_length=20, choices=TYPE_CHOICES)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    currency = models.CharField(max_length=3, default='RUB')
    related_payment = models.ForeignKey(
        Payment,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='transaction_entries'
    )
    description = models.TextField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        db_table = 'transaction_history'
        indexes = [
            models.Index(fields=['user', 'created_at']),
        ]

    def __str__(self):
        return f"{self.type} {self.amount} {self.currency}"


############################################################

apps\payments\serializers.py
============================================================
from rest_framework import serializers
from apps.payments.models import Payment, TransactionHistoryEntry, PaymentMethodRef

class PaymentMethodRefSerializer(serializers.ModelSerializer):
    class Meta:
        model = PaymentMethodRef
        fields = [
            'id',
            'user',
            'provider',
            'stripe_payment_method_id',
            'is_default',
            'created_at',
            'updated_at'
        ]
        read_only_fields = ['id', 'user', 'created_at', 'updated_at']


class PaymentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Payment
        fields = [
            'id', 'user', 'invoice', 'amount', 'currency', 'status',
            'provider', 'provider_payment_id', 'idempotency_key',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'user', 'provider_payment_id', 'created_at', 'updated_at']

    def create(self, validated_data):
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω–∏ user –∏–∑ request
        validated_data['user'] = self.context['request'].user
        return super().create(validated_data)


class PaymentDetailSerializer(serializers.ModelSerializer):
    """–î–µ—Ç–∞–ª—å–Ω—ã–π —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ç–æ—Ä –ø–ª–∞—Ç–µ–∂–∞"""
    invoice_details = serializers.SerializerMethodField()

    class Meta:
        model = Payment
        fields = [
            'id',
            'invoice',
            'invoice_details',
            'status',
            'amount',
            'currency',
            'provider',
            'provider_payment_id',
            'raw_request',
            'raw_response',
            'retry_count',
            'next_retry_at',
            'created_at',
            'updated_at',
        ]
        read_only_fields = fields

    @staticmethod
    def get_invoice_details(obj):
        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ —Å—á—ë—Ç–∞"""
        from apps.subscriptions.serializers import InvoiceSerializer
        return InvoiceSerializer(obj.invoice).data


class TransactionHistorySerializer(serializers.ModelSerializer):
    """–°–µ—Ä–∏–∞–ª–∏–∑–∞—Ç–æ—Ä –¥–ª—è –∏—Å—Ç–æ—Ä–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–π"""
    subscription_name = serializers.CharField(
        source='subscription.plan.name',
        read_only=True
    )

    class Meta:
        model = TransactionHistoryEntry
        fields = [
            'id',
            'subscription',
            'subscription_name',
            'type',
            'amount',
            'currency',
            'description',
            'created_at',
        ]
        read_only_fields = fields

############################################################

apps\payments\tasks.py
============================================================
import logging
from datetime import timedelta
from celery import shared_task
from django.utils import timezone

from apps.payments.models import Payment

logger = logging.getLogger(__name__)


@shared_task(bind=True, max_retries=2)
def cleanup_old_payments(self):
    """–û—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã–µ –ø–ª–∞—Ç–µ–∂–∏ (—Å—Ç–∞—Ä—à–µ 90 –¥–Ω–µ–π)"""
    try:
        logger.info("üßπ Starting cleanup of old payments...")

        ninety_days_ago = timezone.now() - timedelta(days=90)
        old_payments = Payment.objects.filter(created_at__lt=ninety_days_ago)
        count = old_payments.count()

        logger.info(f"Found {count} old payments to cleanup")

        # –û—á–∏—Å—Ç–∏—Ç—å raw request/response –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
        old_payments.update(raw_request=None, raw_response=None)

        logger.info(f"‚úÖ Cleaned up {count} old payments")
        return {'cleaned': count}

    except Exception as exc:
        logger.error(f"‚ùå Error in cleanup: {exc}", exc_info=True)
        raise self.retry(exc=exc, countdown=3600)

############################################################

apps\payments\urls.py
============================================================
from rest_framework.routers import SimpleRouter  # ‚Üê –ò–ó–ú–ï–ù–ò
from apps.payments.views import (
    PaymentViewSet,
    TransactionHistoryViewSet,
    PaymentMethodRefViewSet,
)

router = SimpleRouter()  # ‚Üê –ò–ó–ú–ï–ù–ò
router.register(r'payment-methods', PaymentMethodRefViewSet, basename='payment-method')
router.register(r'payments', PaymentViewSet, basename='payment')
router.register(r'transactions', TransactionHistoryViewSet, basename='transaction')

urlpatterns = router.urls


############################################################

apps\payments\views.py
============================================================
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.pagination import PageNumberPagination
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import OrderingFilter
import logging

from apps.payments.models import Payment, TransactionHistoryEntry, PaymentMethodRef
from apps.payments.serializers import (
    PaymentSerializer,
    PaymentDetailSerializer,
    TransactionHistorySerializer,
    PaymentMethodRefSerializer,
)
from core.services import PaymentService

logger = logging.getLogger(__name__)


class StandardPageNumberPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 100


class PaymentMethodRefViewSet(viewsets.ModelViewSet):
    serializer_class = PaymentMethodRefSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardPageNumberPagination

    def get_queryset(self):
        return PaymentMethodRef.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)


class PaymentViewSet(viewsets.ModelViewSet):
    serializer_class = PaymentSerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardPageNumberPagination
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_fields = ['status']
    ordering_fields = ['created_at']
    ordering = ['-created_at']

    def get_queryset(self):
        return Payment.objects.filter(user=self.request.user)

    def get_serializer_class(self):
        if self.action == 'retrieve':
            return PaymentDetailSerializer
        return PaymentSerializer

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def refund(self, request, pk=None):
        try:
            payment = self.get_object()
            amount = request.data.get('amount', payment.amount)

            service = PaymentService()
            response = service.refund_payment(payment.id, amount=amount)

            return Response(
                {'status': 'Refund initiated', 'payment_id': payment.id},
                status=status.HTTP_200_OK
            )

        except Payment.DoesNotExist:
            logger.error(f"Payment {pk} not found")
            return Response(
                {'error': 'Payment not found'},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error refunding payment: {e}", exc_info=True)
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )


class TransactionHistoryViewSet(viewsets.ReadOnlyModelViewSet):
    serializer_class = TransactionHistorySerializer
    permission_classes = [IsAuthenticated]
    pagination_class = StandardPageNumberPagination
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_fields = ['type']
    ordering_fields = ['created_at']
    ordering = ['-created_at']

    def get_queryset(self):
        return TransactionHistoryEntry.objects.filter(user=self.request.user)

############################################################

apps\subscriptions\models.py
============================================================
from django.db import models
from django.contrib.auth.models import User


class Plan(models.Model):
    BILLING_PERIOD_CHOICES = [
        ('MONTH', 'Monthly'),
        ('YEAR', 'Yearly'),
    ]

    name = models.CharField(max_length=100)
    price_amount = models.DecimalField(max_digits=10, decimal_places=2)
    currency = models.CharField(max_length=3, default='RUB')
    billing_period = models.CharField(
        max_length=10,
        choices=BILLING_PERIOD_CHOICES,
        default='MONTH'
    )
    trial_days = models.IntegerField(default=0)
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'plans'

    def __str__(self):
        return f"{self.name} ({self.price_amount} {self.currency})"


class Subscription(models.Model):
    STATUS_CHOICES = [
        ('TRIALING', 'Trialing'),
        ('ACTIVE', 'Active'),
        ('PAST_DUE', 'Past Due'),
        ('CANCELED', 'Canceled'),
        ('EXPIRED', 'Expired'),
    ]

    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='subscriptions')
    plan = models.ForeignKey(Plan, on_delete=models.CASCADE)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='ACTIVE')
    current_period_start = models.DateField()
    current_period_end = models.DateField()
    next_billing_at = models.DateTimeField(null=True, blank=True)
    cancel_at_period_end = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        db_table = 'subscriptions'
        indexes = [
            models.Index(fields=['next_billing_at', 'status']),
        ]

    def __str__(self):
        return f"{self.user.username} - {self.plan.name}"


############################################################

apps\subscriptions\serializers.py
============================================================
from rest_framework import serializers
from apps.subscriptions.models import Plan, Subscription
from apps.payments.models import Invoice

class PlanSerializer(serializers.ModelSerializer):
    class Meta:
        model = Plan
        fields = ['id', 'name', 'price_amount', 'currency', 'billing_period', 'trial_days', 'is_active', 'created_at']
        read_only_fields = ['id', 'created_at']


class InvoiceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Invoice
        fields = ['id', 'subscription', 'amount', 'currency', 'status', 'billing_period_start', 'billing_period_end', 'created_at']
        read_only_fields = ['id', 'created_at']


class SubscriptionSerializer(serializers.ModelSerializer):
    plan = PlanSerializer(read_only=True)
    plan_id = serializers.IntegerField(write_only=True)

    class Meta:
        model = Subscription
        fields = ['id', 'user', 'plan', 'plan_id', 'status', 'current_period_start', 'current_period_end', 'cancel_at_period_end', 'created_at', 'updated_at']
        read_only_fields = ['id', 'user', 'created_at', 'updated_at']


class SubscriptionDetailSerializer(serializers.ModelSerializer):
    plan = PlanSerializer(read_only=True)
    invoices = InvoiceSerializer(many=True, read_only=True)

    class Meta:
        model = Subscription
        fields = ['id', 'user', 'plan', 'status', 'current_period_start', 'current_period_end', 'cancel_at_period_end', 'invoices', 'created_at', 'updated_at']
        read_only_fields = ['id', 'user', 'invoices', 'created_at', 'updated_at']


class SubscriptionUpdateSerializer(serializers.ModelSerializer):
    class Meta:
        model = Subscription
        fields = ['status', 'cancel_at_period_end']


############################################################

apps\subscriptions\tasks.py
============================================================
import logging
from datetime import timedelta
from celery import shared_task
from django.utils import timezone

from apps.subscriptions.models import Subscription
from apps.payments.models import Payment
from core.services import BillingService

logger = logging.getLogger(__name__)


@shared_task(bind=True, max_retries=3)
def process_billing_cycle(self):
    """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ü–∏–∫–ª –±–∏–ª–ª–∏–Ω–≥–∞"""
    try:
        logger.info("üîÑ Starting billing cycle...")

        service = BillingService()
        result = service.process_billing_cycle()

        logger.info(
            f"‚úÖ Billing cycle completed: "
            f"processed={result['processed']}, "
            f"failed={result['failed']}"
        )

        return result

    except Exception as exc:
        logger.error(f"‚ùå Error in billing cycle: {exc}", exc_info=True)
        raise self.retry(exc=exc, countdown=300)


@shared_task(bind=True, max_retries=3)
def retry_failed_payments(self):
    """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –Ω–µ—É–¥–∞—á–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏"""
    try:
        logger.info("üîÑ Starting retry failed payments...")

        service = BillingService()
        result = service.retry_failed_payments()

        logger.info(
            f"‚úÖ Retried failed payments: "
            f"retried={result['retried']}"
        )

        return result

    except Exception as exc:
        logger.error(f"‚ùå Error in retry payments: {exc}", exc_info=True)
        raise self.retry(exc=exc, countdown=300)

############################################################

apps\subscriptions\urls.py
============================================================
from rest_framework.routers import SimpleRouter  # ‚Üê –ò–ó–ú–ï–ù–ò
from apps.subscriptions.views import PlanViewSet, SubscriptionViewSet

router = SimpleRouter()  # ‚Üê –ò–ó–ú–ï–ù–ò
router.register(r'plans', PlanViewSet, basename='plan')
router.register(r'subscriptions', SubscriptionViewSet, basename='subscription')

urlpatterns = router.urls


############################################################

apps\subscriptions\views.py
============================================================
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from rest_framework.pagination import PageNumberPagination
from django_filters.rest_framework import DjangoFilterBackend
from rest_framework.filters import SearchFilter, OrderingFilter
import logging

from apps.subscriptions.models import Plan, Subscription
from apps.subscriptions.serializers import (
    PlanSerializer,
    SubscriptionSerializer,
    SubscriptionDetailSerializer,
    SubscriptionUpdateSerializer,
)
from core.services import SubscriptionService

logger = logging.getLogger(__name__)


class StandardPageNumberPagination(PageNumberPagination):
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 100


class PlanViewSet(viewsets.ModelViewSet):
    queryset = Plan.objects.all()  # ‚Üê —Ç–æ–∂–µ –∏–∑–º–µ–Ω–∏ (—É–±–µ—Ä–∏ filter)
    serializer_class = PlanSerializer
    pagination_class = StandardPageNumberPagination
    filter_backends = [SearchFilter, OrderingFilter]
    search_fields = ['name']
    ordering_fields = ['price_amount', 'created_at']
    ordering = ['price_amount']


class SubscriptionViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]
    pagination_class = StandardPageNumberPagination
    filter_backends = [DjangoFilterBackend, OrderingFilter]
    filterset_fields = ['status', 'plan']
    ordering_fields = ['created_at', 'current_period_end']
    ordering = ['-created_at']

    def get_queryset(self):
        return Subscription.objects.filter(user=self.request.user)

    def get_serializer_class(self):
        if self.action == 'retrieve':
            return SubscriptionDetailSerializer
        elif self.action in ['update', 'partial_update']:
            return SubscriptionUpdateSerializer
        return SubscriptionSerializer

    def create(self, request, *args, **kwargs):
        try:
            plan_id = request.data.get('plan_id')
            payment_method_id = request.data.get('payment_method_id')

            if not plan_id:
                return Response(
                    {'error': 'plan_id is required'},
                    status=status.HTTP_400_BAD_REQUEST
                )

            service = SubscriptionService()
            subscription = service.create_subscription(
                user=request.user,
                plan_id=plan_id,
                payment_method_id=payment_method_id,
            )

            serializer = SubscriptionDetailSerializer(subscription)
            return Response(serializer.data, status=status.HTTP_201_CREATED)

        except Plan.DoesNotExist:
            return Response(
                {'error': 'Plan not found'},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error creating subscription: {e}", exc_info=True)
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

    def partial_update(self, request, *args, **kwargs):
        subscription = self.get_object()

        if 'cancel_at_period_end' in request.data:
            subscription.cancel_at_period_end = request.data.get('cancel_at_period_end')
            subscription.save()

        serializer = self.get_serializer(subscription)
        return Response(serializer.data)

    def destroy(self, request, *args, **kwargs):
        subscription = self.get_object()

        try:
            service = SubscriptionService()
            service.cancel_subscription(subscription.id, immediate=True)
            return Response(status=status.HTTP_204_NO_CONTENT)
        except Exception as e:
            logger.error(f"Error deleting subscription: {e}", exc_info=True)
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

    @action(detail=True, methods=['post'], permission_classes=[IsAuthenticated])
    def cancel(self, request, pk=None):
        try:
            service = SubscriptionService()
            immediate = request.data.get('immediate', False)

            subscription = service.cancel_subscription(pk, immediate=immediate)
            serializer = SubscriptionDetailSerializer(subscription)
            return Response(serializer.data)

        except Subscription.DoesNotExist:
            logger.error(f"Subscription {pk} not found")
            return Response(
                {'error': 'Subscription not found'},
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            logger.error(f"Error canceling subscription: {e}", exc_info=True)
            return Response(
                {'error': str(e)},
                status=status.HTTP_400_BAD_REQUEST
            )

############################################################

config\celery.py
============================================================
import os
from celery import Celery
from celery.schedules import crontab

# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –º–æ–¥—É–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

app = Celery('subscription_system')

# –ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –∏–∑ Django settings
app.config_from_object('django.conf:settings', namespace='CELERY')

# Auto-discover tasks –∏–∑ –≤—Å–µ—Ö –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö Django apps
app.autodiscover_tasks()

# –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è Celery Beat
app.conf.beat_schedule = {
    'process-billing-every-hour': {
        'task': 'apps.subscriptions.tasks.process_billing_cycle',
        'schedule': crontab(minute=0),  # –ö–∞–∂–¥—ã–π —á–∞—Å –≤ :00
    },
    'retry-failed-payments-every-hour': {
        'task': 'apps.subscriptions.tasks.retry_failed_payments',
        'schedule': crontab(minute=15),  # –ö–∞–∂–¥—ã–π —á–∞—Å –≤ :15
    },
    'cleanup-old-payments': {
        'task': 'apps.payments.tasks.cleanup_old_payments',
        'schedule': crontab(day_of_week=1, hour=2, minute=0),  # –ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫ –≤ 02:00
    },
}

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–¥–∞—á
app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='Europe/Moscow',
    enable_utc=True,
    task_track_started=True,
    task_time_limit=30 * 60,  # 30 –º–∏–Ω—É—Ç hard time limit
    task_soft_time_limit=25 * 60,  # 25 –º–∏–Ω—É—Ç soft time limit
    result_expires=3600,  # –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –∏—Å—Ç–µ–∫–∞—é—Ç —á–µ—Ä–µ–∑ 1 —á–∞—Å
    worker_prefetch_multiplier=4,
    worker_max_tasks_per_child=1000,
)


@app.task(bind=True)
def debug_task(self):
    """Debug task –¥–ª—è Celery"""
    print(f'Request: {self.request!r}')

############################################################

config\settings.py
============================================================
"""
Django settings for subscription project.
"""

import os
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = 'boom'

DEBUG = True

ALLOWED_HOSTS = [
    '127.0.0.1',
    'localhost',
    '0.0.0.0',
]

# Application definition
INSTALLED_APPS = [
    # Django apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Third party apps
    'rest_framework',
    'django_filters',
    'corsheaders',

    # Local apps
    'apps.subscriptions',
    'apps.payments',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# Database
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
LANGUAGE_CODE = 'ru'
TIME_ZONE = 'Europe/Moscow'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]

# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# ============================================================================
# REST FRAMEWORK CONFIGURATION
# ============================================================================

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
        'rest_framework.filters.SearchFilter',
        'rest_framework.filters.OrderingFilter',
    ],
    'DEFAULT_THROTTLE_CLASSES': [
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle',
    ],
    'DEFAULT_THROTTLE_RATES': {
        'anon': '100/hour',
        'user': '1000/hour',
    },
    'EXCEPTION_HANDLER': 'rest_framework.views.exception_handler',
}

# ============================================================================
# CORS CONFIGURATION
# ============================================================================

CORS_ALLOWED_ORIGINS = [
    'http://localhost:3000',
    'http://localhost:8000',
    'http://127.0.0.1:3000',
    'http://127.0.0.1:8000',
]

CORS_ALLOW_CREDENTIALS = True

# ============================================================================
# CELERY CONFIGURATION (–¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á)
# ============================================================================

CELERY_BROKER_URL = os.getenv('CELERY_BROKER_URL', 'redis://localhost:6379/0')
CELERY_RESULT_BACKEND = os.getenv('CELERY_RESULT_BACKEND', 'redis://localhost:6379/0')
CELERY_ACCEPT_CONTENT = ['json']
CELERY_TASK_SERIALIZER = 'json'
CELERY_RESULT_SERIALIZER = 'json'
CELERY_TIMEZONE = TIME_ZONE

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse',
        },
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'class': 'logging.StreamHandler',
            'formatter': 'simple',
        },
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(BASE_DIR, 'logs', 'django.log'),
            'maxBytes': 1024 * 1024 * 10,  # 10MB
            'backupCount': 5,
            'formatter': 'verbose',
        },
    },
    'root': {
        'handlers': ['console', 'file'],
        'level': 'INFO',
    },
    'loggers': {
        'django': {
            'handlers': ['console', 'file'],
            'level': 'INFO',
            'propagate': False,
        },
        'core.services': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'apps.payments': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
        'apps.subscriptions': {
            'handlers': ['console', 'file'],
            'level': 'DEBUG',
            'propagate': False,
        },
    },
}

# Create logs directory if it doesn't exist
os.makedirs(os.path.join(BASE_DIR, 'logs'), exist_ok=True)

# ============================================================================
# SECURITY SETTINGS (–¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞)
# ============================================================================

if not DEBUG:
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_SECURITY_POLICY = {
        'default-src': ("'self'",),
        'script-src': ("'self'", "'unsafe-inline'"),
        'style-src': ("'self'", "'unsafe-inline'"),
    }


############################################################

config\urls.py
============================================================
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('apps.subscriptions.urls')),
    path('api/', include('apps.payments.urls')),
]

############################################################

config\wsgi.py
============================================================
"""
WSGI config for subscription project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()


############################################################

config\__init__.py
============================================================
from .celery import app as celery_app

__all__ = ('celery_app',)

############################################################

core\asgi.py
============================================================
"""
ASGI config for core project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.2/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()


############################################################

core\__init__.py
============================================================


############################################################

core\jobs\billing_job.py
============================================================
from celery import shared_task
from core.services import BillingService

@shared_task
def process_billing():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —á–∞—Å"""
    service = BillingService()
    result = service.process_billing_cycle()
    print(f"Billing: {result}")
    return result

@shared_task
def retry_failed_payments():
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —á–∞—Å –≤ :15"""
    service = BillingService()
    result = service.retry_failed_payments()
    print(f"Retry: {result}")
    return result

############################################################

core\jobs\dunnig_job.py
============================================================
from celery import shared_task
import logging

logger = logging.getLogger(__name__)

@shared_task
def process_dunning():
    """–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –∏ –æ—Ç–º–µ–Ω—ã"""
    logger.info("Dunning job started")
    logger.info("Dunning job completed")

############################################################

core\jobs\retry_job.py
============================================================
from celery import shared_task
import logging

logger = logging.getLogger(__name__)

@shared_task
def retry_failed_payments():
    """–ü–æ–≤—Ç–æ—Ä–Ω—ã–µ –ø–æ–ø—ã—Ç–∫–∏"""
    logger.info("Retry job started")
    logger.info("Retry job completed")

############################################################

core\payment_gateway\base.py
============================================================
from abc import ABC, abstractmethod


class PaymentGateway(ABC):
    """–ê–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è –ø–ª–∞—Ç—ë–∂–Ω—ã—Ö —à–ª—é–∑–æ–≤"""

    @abstractmethod
    def create_payment(self, payment, method):
        pass

    @abstractmethod
    def refund_payment(self, payment, amount, reason):
        pass

    @abstractmethod
    def get_payment_status(self, provider_payment_id):
        pass

    @abstractmethod
    def save_payment_method(self, user_id, payment_token):
        pass

############################################################

core\payment_gateway\fake.py
============================================================
import hashlib
import random
from datetime import datetime
from .base import PaymentGateway


class FakeGateway(PaymentGateway):
    """–§–µ–π–∫–æ–≤—ã–π —à–ª—é–∑ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏"""

    def __init__(self, failure_rate=0.1):
        self.failure_rate = failure_rate

    def create_payment(self, payment, method):
        should_fail = random.random() < self.failure_rate
        return {
            'provider_payment_id': hashlib.sha256(
                f"{payment.id}{datetime.now()}".encode()
            ).hexdigest(),
            'status': 'FAILED' if should_fail else 'SUCCEEDED',
            'error_code': None if not should_fail else 'ERROR',
            'created_at': datetime.now(),
        }

    def refund_payment(self, payment, amount, reason):
        return {'status': 'SUCCEEDED'}

    def get_payment_status(self, provider_payment_id):
        return {'status': 'SUCCEEDED'}

    def save_payment_method(self, user_id, payment_token):
        return {'provider_payment_id': hashlib.sha256(
            f"{user_id}_{payment_token}".encode()
        ).hexdigest()}

############################################################

core\payment_gateway\__init__.py
============================================================
from .base import PaymentGateway
from .fake import FakeGateway

def get_payment_gateway():
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–ª–∞—Ç—ë–∂–Ω–æ–≥–æ —à–ª—é–∑–∞"""
    return FakeGateway()

__all__ = ['PaymentGateway', 'FakeGateway', 'get_payment_gateway']

############################################################

core\services\billing_service.py
============================================================
from datetime import datetime, timedelta
from django.db import transaction
from apps.subscriptions.models import Subscription
from apps.payments.models import Invoice

from apps.payments.models import Payment, TransactionHistoryEntry
from core.payment_gateway import get_payment_gateway
from .subscription_service import SubscriptionService


class BillingService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω–æ–≥–æ –±–∏–ª–ª–∏–Ω–≥–∞ –ø–æ–¥–ø–∏—Å–æ–∫"""

    def __init__(self):
        self.gateway = get_payment_gateway()
        self.subscription_service = SubscriptionService()

    def process_billing_cycle(self):
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏, –≥–æ—Ç–æ–≤—ã–µ –∫ –±–∏–ª–ª–∏–Ω–≥—É"""

        now = datetime.now()

        subscriptions = Subscription.objects.filter(
            status='ACTIVE',
            current_period_end__lte=now.date()
        ).select_for_update()

        processed = 0
        failed = 0

        for subscription in subscriptions:
            try:
                self._bill_single_subscription(subscription)
                processed += 1
            except Exception as e:
                print(f"Error billing subscription {subscription.id}: {e}")
                failed += 1

        return {
            'processed': processed,
            'failed': failed,
            'total': processed + failed,
        }

    def _bill_single_subscription(self, subscription):
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –±–∏–ª–ª–∏–Ω–≥ –æ–¥–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏"""

        with transaction.atomic():
            subscription.refresh_from_db()
            if subscription.status != 'ACTIVE':
                return

            invoice = Invoice.objects.create(
                subscription=subscription,
                user=subscription.user,
                amount=subscription.plan.price_amount,
                currency=subscription.plan.currency,
                status='PENDING',
            )

            payment = self._create_payment_for_invoice(subscription, invoice)

            response = self.gateway.create_payment(payment, None)

            payment.provider_payment_id = response.get('provider_payment_id')
            payment.status = response.get('status', 'FAILED')
            payment.save()

            if response.get('status') == 'SUCCEEDED':
                self._handle_successful_payment(subscription, invoice, payment)
            else:
                self._handle_failed_payment(subscription, invoice, payment)

    @staticmethod
    def _create_payment_for_invoice(subscription, invoice):
        """–°–æ–∑–¥–∞—Ç—å –æ–±—ä–µ–∫—Ç –ø–ª–∞—Ç–µ–∂–∞"""

        import hashlib
        idempotency_key = hashlib.sha256(
            f"{subscription.id}:{invoice.id}:{datetime.now():%Y-%m-%d}".encode()
        ).hexdigest()

        payment = Payment.objects.create(
            invoice=invoice,
            user=subscription.user,
            status='PENDING',
            amount=invoice.amount,
            currency=invoice.currency,
            idempotency_key=idempotency_key,
        )

        return payment

    @staticmethod
    def _handle_successful_payment(subscription, invoice, payment):
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å —É—Å–ø–µ—à–Ω—ã–π –ø–ª–∞—Ç—ë–∂"""

        invoice.status = 'PAID'
        invoice.save()

        subscription.current_period_start = subscription.current_period_end

        if subscription.plan.billing_period == 'MONTH':
            subscription.current_period_end = (
                    subscription.current_period_end + timedelta(days=30)
            )
        else:
            subscription.current_period_end = (
                    subscription.current_period_end + timedelta(days=365)
            )

        subscription.status = 'ACTIVE'
        subscription.save()

        TransactionHistoryEntry.objects.create(
            user=subscription.user,
            subscription=subscription,
            type='CHARGE',
            amount=payment.amount,
            currency=payment.currency,
        )

        print(f"‚úÖ Subscription {subscription.id} charged successfully")

    @staticmethod
    def _handle_failed_payment(subscription, invoice, payment):
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ—É–¥–∞—á–Ω—ã–π –ø–ª–∞—Ç—ë–∂"""

        invoice.status = 'FAILED'
        invoice.save()

        subscription.status = 'PAST_DUE'
        subscription.save()

        print(f"‚ùå Payment failed for subscription {subscription.id}")

    def retry_failed_payments(self):
        """–ü–æ–≤—Ç–æ—Ä–∏—Ç—å –Ω–µ—É–¥–∞—á–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏"""

        failed_payments = Payment.objects.filter(status='FAILED')
        retried = 0

        for payment in failed_payments:
            try:
                # –ü–æ–≤—Ç–æ—Ä –ø–ª–∞—Ç–µ–∂–∞
                response = self.gateway.create_payment(payment, None)

                payment.provider_payment_id = response.get('provider_payment_id')
                payment.status = response.get('status', 'FAILED')
                payment.retry_count += 1
                payment.save()

                if response.get('status') == 'SUCCEEDED':
                    # –£—Å–ø–µ—Ö - –æ–±–Ω–æ–≤–∏ –∏–Ω–≤–æ–π—Å
                    invoice = payment.invoice
                    invoice.status = 'PAID'
                    invoice.save()

                    # –û–±–Ω–æ–≤–∏ –ø–æ–¥–ø–∏—Å–∫—É
                    subscription = invoice.subscription
                    self._handle_successful_payment(subscription, invoice, payment)

                    retried += 1

            except Exception as e:
                print(f"Error retrying payment {payment.id}: {e}")

        return {
            'retried': retried,
            'total': failed_payments.count(),
        }

############################################################

core\services\payment_service.py
============================================================
from apps.payments.models import Payment, TransactionHistoryEntry
from core.payment_gateway import get_payment_gateway


class PaymentService:
    """–°–µ—Ä–≤–∏—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞–º–∏"""

    def __init__(self):
        self.gateway = get_payment_gateway()

    def refund_payment(self, payment_id, amount=None):
        """–í–µ—Ä–Ω—É—Ç—å –¥–µ–Ω—å–≥–∏ –∑–∞ –ø–ª–∞—Ç—ë–∂"""

        payment = Payment.objects.get(id=payment_id)

        if amount is None:
            amount = payment.amount

        response = self.gateway.refund_payment(
            payment,
            amount,
            reason='User requested refund'
        )

        TransactionHistoryEntry.objects.create(
            user=payment.user,
            subscription=payment.invoice.subscription,
            type='REFUND',
            amount=amount,
            currency=payment.currency,
        )

        return response

    @staticmethod
    def list_user_payments(user):
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–ª–∞—Ç–µ–∂–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return Payment.objects.filter(user=user).order_by('-created_at')

    @staticmethod
    def list_user_transactions(user):
        """–ü–æ–ª—É—á–∏—Ç—å –≤—Å—é –∏—Å—Ç–æ—Ä–∏—é –æ–ø–µ—Ä–∞—Ü–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        return TransactionHistoryEntry.objects.filter(
            user=user
        ).order_by('-created_at')

############################################################

core\services\subscription_service.py
============================================================
import hashlib
from datetime import datetime, timedelta
from django.db import transaction
from apps.subscriptions.models import Subscription, Plan
from apps.payments.models import Invoice
from apps.payments.models import Payment, PaymentMethodRef, TransactionHistoryEntry
from core.payment_gateway import get_payment_gateway
from celery import current_app as celery_app

class SubscriptionService:
    def __init__(self):
        self.gateway = get_payment_gateway()

    def create_subscription(self, user, plan_id, payment_method_id=None):
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –ø–æ–¥–ø–∏—Å–∫—É (–æ–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""

        plan = Plan.objects.get(id=plan_id)
        payment_method = None
        if payment_method_id:
            payment_method = PaymentMethodRef.objects.get(id=payment_method_id)

        with transaction.atomic():
            now = datetime.now()
            status = 'TRIALING' if plan.trial_days > 0 else 'ACTIVE'

            current_period_start = now.date()
            if plan.billing_period == 'MONTH':
                current_period_end = (now + timedelta(days=30)).date()
            else:
                current_period_end = (now + timedelta(days=365)).date()

            subscription = Subscription.objects.create(
                user=user,
                plan=plan,
                status=status,
                current_period_start=current_period_start,
                current_period_end=current_period_end,
            )

            invoice_amount = 0 if plan.trial_days > 0 else plan.price_amount

            invoice = Invoice.objects.create(
                subscription=subscription,
                user=user,
                amount=invoice_amount,
                status='PENDING' if invoice_amount > 0 else 'PAID',
            )

            if invoice_amount > 0 and payment_method:
                self._process_payment(subscription, invoice, payment_method)

            return subscription

    def _process_payment(self, subscription, invoice, payment_method):
        """–û–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–ª–∞—Ç—ë–∂"""

        idempotency_key = self._generate_idempotency_key(
            subscription.id,
            invoice.id
        )

        existing = Payment.objects.filter(
            idempotency_key=idempotency_key
        ).first()
        if existing:
            return existing

        payment = Payment.objects.create(
            invoice=invoice,
            user=subscription.user,
            status='PENDING',
            amount=invoice.amount,
            provider_payment_id=None,
            idempotency_key=idempotency_key,
        )

        try:
            response = self.gateway.create_payment(payment, payment_method)

            payment.provider_payment_id = response.get('provider_payment_id')
            payment.status = response.get('status', 'FAILED')
            payment.save()

            if response.get('status') == 'SUCCEEDED':
                invoice.status = 'PAID'
                invoice.save()

                subscription.status = 'ACTIVE'
                subscription.save()

                TransactionHistoryEntry.objects.create(
                    user=subscription.user,
                    subscription=subscription,
                    type='CHARGE',
                    amount=payment.amount,
                )
            else:
                invoice.status = 'FAILED'
                invoice.save()
                subscription.status = 'PAST_DUE'
                subscription.save()

        except Exception as e:
            payment.status = 'ERROR'
            payment.save()
            raise

        return payment

    @staticmethod
    def cancel_subscription(subscription_id, immediate=False):
        """–û—Ç–º–µ–Ω–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É"""

        subscription = Subscription.objects.get(id=subscription_id)

        if immediate:
            subscription.status = 'CANCELED'
        else:
            subscription.cancel_at_period_end = True

        subscription.save()
        return subscription

    @staticmethod
    def _generate_idempotency_key(subscription_id, invoice_id):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∫–ª—é—á –¥–ª—è –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏"""
        key = f"{subscription_id}:{invoice_id}:{datetime.now():%Y-%m-%d}"
        return hashlib.sha256(key.encode()).hexdigest()

############################################################

core\services\__init__.py
============================================================
from .subscription_service import SubscriptionService
from .billing_service import BillingService
from .payment_service import PaymentService
__all__ = [
    'SubscriptionService',
    'BillingService',
    'PaymentService',
]

############################################################

tests\conftest.py
============================================================
import pytest
from django.contrib.auth.models import User
from apps.subscriptions.models import Plan
from apps.payments.models import PaymentMethodRef
import factory

@pytest.fixture
def user():
    return User.objects.create_user(email='test@example.com', password='testpass')

@pytest.fixture
def plan():
    return Plan.objects.create(
        name='Basic',
        price_amount=100,
        billing_period='MONTH',
        trial_days=0
    )

@pytest.fixture
def payment_method(user):
    return PaymentMethodRef.objects.create(
        user=user,
        provider='fake',
        provider_customer_id='cust_123',
        provider_payment_method_id='method_123',
        is_default=True
    )

############################################################

